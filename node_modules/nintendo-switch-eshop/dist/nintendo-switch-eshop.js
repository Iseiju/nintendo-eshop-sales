"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const querystring_1 = require("@favware/querystring");
const country_data_1 = require("country-data");
const fast_xml_parser_1 = require("fast-xml-parser");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const util_1 = require("util");
const constants = tslib_1.__importStar(require("./constants"));
const interfaces = tslib_1.__importStar(require("./interfaces"));
/**
 * Removed duplicates from an array
 *
 * @param array The input array
 * @param property The property to check
 * @private
 */
const arrayRemoveDuplicates = (array, property) => {
    const index = [];
    return array.filter(item => {
        const key = property ? item[property] : item;
        return index.includes(key) ? false : index.push(key);
    });
};
/**
 * Checks if object has a certain property
 *
 * @param obj Object to traverse
 * @param prop Property to find
 * @private
 */
const hasProp = (obj, prop) => obj && prop in obj;
/**
 * TypeGuard to check if the variable is an array of strings
 *
 * @param array Array to check
 * @returns Boolean representing whether the input is an array
 * @private
 */
const isStringArray = (array) => {
    return Array.isArray(array);
};
/**
 * Fetches all games on american eshops
 *
 * @remarks
 * Paginates every 200 games, _(maximum item count per request)_
 *
 * @param options _(Optional)_ Options for the request
 * @param offset _(Optional)_ Offset to start searching at
 * @param games _(Optional)_ Array of games to filter by
 * @returns Promise containing all the games
 */
exports.getGamesAmerica = (options = {}, offset = 0, games = []) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const limit = hasProp(options, 'limit') ? options.limit : constants.US_GAME_LIST_LIMIT;
    const shopProp = hasProp(options, 'shop') ? options.shop : 'ncom';
    let shop = shopProp === 'all' ? ['ncom', 'retail'] : shopProp;
    shop = shop === 'unfiltered' ? undefined : shop;
    const page = Math.floor(offset / limit);
    const shopMapper = (shopType) => {
        switch (shopType) {
            case 'ncom':
                return 'filterShops:On Nintendo.com';
            case 'retail':
                return 'filterShops:On retail';
            default:
                return '';
        }
    };
    let shopFilters = [''];
    if (shop) {
        shopFilters = isStringArray(shop) ? shop.map(value => shopMapper(value)) : shopMapper(shop);
    }
    const sortingOptions = {
        direction: constants.US_GET_GAMES_OPTIONS.direction,
        sortBy: constants.US_GET_GAMES_OPTIONS.sort,
    };
    const body = {
        body: JSON.stringify({
            requests: [
                {
                    indexName: `noa_aem_game_en_us${(sortingOptions.sortBy && sortingOptions.direction
                        ? `_${sortingOptions.sortBy}_${sortingOptions.direction}` : '')}`,
                    params: querystring_1.stringify({
                        facetFilters: [
                            [constants.US_GET_GAMES_OPTIONS.system],
                            shopFilters
                        ],
                        hitsPerPage: limit,
                        page,
                    }),
                }
            ],
        }),
        headers: constants.US_ALGOLIA_HEADERS,
        method: 'POST',
    };
    try {
        if (hasProp(options, 'limit')) {
            const gamesUS = yield node_fetch_1.default(constants.US_GET_GAMES_URL, body);
            if (!gamesUS.ok)
                throw new Error('US_games_request_failed');
            const filteredResponse = yield gamesUS.json();
            const accumulatedGames = arrayRemoveDuplicates(games.concat(filteredResponse.results[0].hits), 'slug');
            if (!hasProp(options, 'limit') && filteredResponse.results[0].hits.length + offset < filteredResponse.results[0].nbHits) {
                return yield exports.getGamesAmerica(options, offset + limit, accumulatedGames);
            }
            return accumulatedGames;
        }
        /**
         * Using a workaround to get all the games.
         * Basically, fetch all the games from the different categories one by one,
         * if one category has > 100 games, fetch all the games in each price range one by one.
         *
         * Get the counts of all the games in the different categories.
         */
        const categoriesRequestOptions = {
            body: JSON.stringify({
                requests: [{
                        indexName: 'noa_aem_game_en_us',
                        params: querystring_1.stringify({
                            facetFilters: [
                                [constants.US_GET_GAMES_OPTIONS.system],
                                shopFilters
                            ],
                            facets: [
                                'categories'
                            ],
                            hitsPerPage: 0,
                        }),
                    }],
            }),
            headers: constants.US_ALGOLIA_HEADERS,
            method: 'POST',
        };
        const gamesToCount = yield node_fetch_1.default(constants.US_GET_GAMES_URL, categoriesRequestOptions);
        if (!gamesToCount.ok)
            throw new Error('US_games_request_failed');
        const response = yield gamesToCount.json();
        const categoryCount = response.results[0].facets.categories;
        // Loop through all the categories and fetch the games.
        const allGamesPromises = Object.entries(categoryCount).map(([category, count]) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const normalRequest = [{
                    indexName: 'noa_aem_game_en_us',
                    params: querystring_1.stringify({
                        facetFilters: JSON.stringify([
                            [constants.US_GET_GAMES_OPTIONS.system],
                            [`categories:${category}`],
                            shopFilters
                        ]),
                        hitsPerPage: 100,
                    }),
                }];
            const manyPriceRangeRequests = constants.US_PRICE_RANGES.map(priceRange => ({
                indexName: 'noa_aem_game_en_us',
                params: querystring_1.stringify({
                    facetFilters: JSON.stringify([
                        [constants.US_GET_GAMES_OPTIONS.system],
                        [`categories:${category}`],
                        [`priceRange:${priceRange}`],
                        shopFilters
                    ]),
                    facets: [
                        'platform',
                        'categories'
                    ],
                    hitsPerPage: 100,
                }),
            }));
            const allGamesRequestOptions = {
                body: JSON.stringify({ requests: count > 100 ? manyPriceRangeRequests : normalRequest }),
                headers: constants.US_ALGOLIA_HEADERS,
                method: 'POST',
            };
            const allGamesResponse = yield node_fetch_1.default(constants.US_GET_GAMES_URL, allGamesRequestOptions);
            if (!allGamesResponse.ok)
                throw new Error('US_games_request_failed');
            const gamesResponse = yield allGamesResponse.json();
            return count > 100
                ? gamesResponse.results
                    .map(result => result.hits)
                    .reduce((a, b) => a.concat(b, []))
                : gamesResponse.results[0].hits;
        }));
        // Finally fetch all the games and remove duplicates
        let allGames = (yield Promise.all(allGamesPromises)).reduce((a, b) => a.concat(b, []));
        allGames = arrayRemoveDuplicates(allGames, 'slug');
        return allGames;
    }
    catch (err) {
        if (/(?:US_games_request_failed)/i.test(err.toString()))
            throw new constants.EshopError('Fetching of US Games failed');
        throw err;
    }
});
/**
 * Fetches all games on japanese eShops
 *
 * @returns Promise containing all the games
 */
exports.getGamesJapan = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const gamesJP = yield node_fetch_1.default(constants.JP_GET_GAMES_URL);
        if (!gamesJP.ok)
            throw new Error('JP_games_request_failed');
        const parsedGamesJP = fast_xml_parser_1.parse(yield gamesJP.text());
        const allGamesJP = parsedGamesJP.TitleInfoList.TitleInfo;
        return allGamesJP;
    }
    catch (err) {
        if (/(?:JP_games_request_failed)/i.test(err.toString()))
            throw new constants.EshopError('Fetching of JP Games failed');
        throw err;
    }
});
/**
 * Fetches all games on the European, Australian or New Zealand eShops
 *
 * @remarks
 * Games from Australia / New Zealand can be limited. They are included only as much as that Nintendo assigns them properly to the PAL region
 *
 * @param options - Request options to pass to the eShop request {@link EURequestOptions | See EURequestOptions for details}
 * @returns Promise containing all requested EU/PAL games
 */
exports.getGamesEurope = (options = { limit: constants.EU_GAME_LIST_LIMIT, locale: constants.EU_DEFAULT_LOCALE }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!options.limit)
        options.limit = constants.EU_GAME_LIST_LIMIT;
    if (!options.locale)
        options.locale = constants.EU_DEFAULT_LOCALE;
    try {
        const gamesEU = yield node_fetch_1.default(`${constants.EU_GET_GAMES_URL.replace('{locale}', options.locale)}?${querystring_1.stringify(Object.assign({ rows: options.limit }, constants.EU_GET_GAMES_OPTIONS))}`);
        if (!gamesEU.ok)
            throw new Error('EU_games_request_failed');
        const gamesData = yield gamesEU.json();
        return gamesData.response.docs;
    }
    catch (err) {
        if (/(?:EU_games_request_failed)/i.test(err.toString()))
            throw new constants.EshopError('Fetching of EU Games failed');
        throw err;
    }
});
/**
 * Gets pricing information for the requested games. Paginates every 50 games.
 *
 * @param country A two digit country code. (ISO 3166-1 alpha-2 country code)
 * @param gameIds One or more NSUID of the corresponding games.
 * @param offset _(Optional)_ The offset to start at
 * @param prices _(Optional)_ An array of {@link TitleData}
 * @returns A promise containing the pricing information.
 */
exports.getPrices = (country, gameIds, offset = 0, prices = []) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const filteredIds = gameIds.slice(offset, offset + constants.PRICE_LIST_LIMIT);
        const priceData = yield node_fetch_1.default(`${constants.PRICE_GET_URL}?${querystring_1.stringify(Object.assign({ country, ids: filteredIds, limit: constants.PRICE_LIST_LIMIT }, constants.PRICE_GET_OPTIONS))}`);
        if (priceData.status === 403)
            throw new Error('PRICE_Rate_Limit');
        if (!priceData.ok)
            throw new Error('PRICE_get_request_failed');
        const response = yield priceData.json();
        if (response.prices && response.prices.length + offset < gameIds.length) {
            const accumulatedPrices = prices.concat(response.prices);
            return yield exports.getPrices(country, gameIds, offset + constants.PRICE_LIST_LIMIT, accumulatedPrices);
        }
        else if (response.prices) {
            response.prices = response.prices.concat(prices);
            return response;
        }
        return response;
    }
    catch (err) {
        if (/(?:PRICE_Rate_Limit)/i.test(err.toString()))
            throw new constants.EshopError('Looks like you ran into a rate limit while getting price data, please do not spam the Nintendo servers.');
        if (/(?:PRICE_get_request_failed)/i.test(err.toString()))
            throw new constants.EshopError('Fetching of eShop prices failed');
        throw err;
    }
});
/**
 * Gets all active eShops given a list of countries.
 *
 * @param countryCodes A list of 2 digit country codes for every country eShop to lookup. (ISO 3166-1 alpha-2 country codes)
 * @param gameCode A 14 digits game NSUID from the desired region.
 * @param region A region id that will be appended in the final shop object for filtering purposes.
 * @returns A list of shop objects with country code, name and default currency.
 */
exports.getShopsByCountryCodes = (countryCodes, gameCode, region) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const countryList = countryCodes.map((code) => country_data_1.countries.all.filter((country) => country.alpha2 === code)[0]);
        const shops = [];
        for (const country of countryList) {
            try {
                const response = yield exports.getPrices(country.alpha2, gameCode);
                response.country = country;
                shops.push(response);
            }
            catch (err) {
                continue;
            }
        }
        const activeShops = shops.filter((shop) => shop && shop.prices && shop.prices.length && shop.prices[0].regular_price);
        const eShops = activeShops.map((shop) => ({
            code: shop.country.alpha2,
            country: shop.country.name,
            currency: shop.prices[0].regular_price.currency,
            region,
        }));
        if (!eShops.length)
            throw new Error('ACTIVE_SHOPS_Rate_Limit');
        return eShops;
    }
    catch (err) {
        if (/(?:ACTIVE_SHOPS_Rate_Limit)/i.test(err.toString()))
            throw new Error('Looks like you ran into a rate limit while getting price data, please do not spam the Nintendo servers.');
        throw new Error(err);
    }
});
/**
 * Gets all active eShops on American countries.
 *
 * @remarks
 * This method will launch several requests at nintendo web services, so don't abuse it.
 *
 * @returns A list of shop objects with country code, name and default currency.
 */
exports.getShopsAmerica = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return exports.getShopsByCountryCodes(country_data_1.regions.southAmerica.countries.concat(country_data_1.regions.centralAfrica.countries, country_data_1.regions.northernAmerica.countries), constants.US_GAME_CHECK_CODE, interfaces.Region.AMERICAS);
});
/**
 * Gets all active eShops on European countries.
 *
 * @remarks
 * This method will launch several requests at nintendo web services, so don't abuse it.
 *
 * @returns A list of shop objects with country code, name and default currency.
 */
exports.getShopsEurope = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return exports.getShopsByCountryCodes(country_data_1.regions.northernEurope.countries.concat(country_data_1.regions.southernEurope.countries, country_data_1.regions.easternEurope.countries, country_data_1.regions.westernEurope.countries, country_data_1.regions.australia.countries, country_data_1.regions.southernAfrica.countries), constants.EU_GAME_CHECK_CODE, interfaces.Region.EUROPE);
});
/**
 * Gets all active eShops on Asian countries
 *
 * @remarks
 * This method will launch several requests at nintendo web services, so don't abuse it.
 *
 * @returns A list of shop objects with country code, name and default currency.
 */
exports.getShopsAsia = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return exports.getShopsByCountryCodes(country_data_1.regions.southernAsia.countries.concat(country_data_1.regions.southernAsia.countries, country_data_1.regions.southeastAsia.countries, country_data_1.regions.eastAsia.countries, country_data_1.regions.westernAsia.countries), constants.JP_GAME_CHECK_CODE, interfaces.Region.ASIA);
});
/**
 * Gets all active eShops.
 *
 * @remarks
 * This method will launch several requests at nintendo web services, so don't abuse it.
 *
 * @returns A list of shop objects with country code, name and default currency.
 */
exports.getActiveShops = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const shopsAmerica = yield exports.getShopsAmerica();
        const shopsAsia = yield exports.getShopsAsia();
        const shopsEurope = yield exports.getShopsEurope();
        return shopsAmerica.concat(shopsAsia, shopsEurope);
    }
    catch (err) {
        throw new Error(err);
    }
});
/**
 * Parses the game code to extract the cross-region portion.
 *
 * @param game The game object returned from one of the other methods.
 * @param region Region code
 * @returns The 4-digit resulting game code
 */
exports.parseGameCode = (game, region) => {
    let codeParse;
    switch (region) {
        default:
        case interfaces.Region.EUROPE:
            codeParse = constants.EU_GAME_CODE_REGEX.exec(game.product_code_txt[0]);
            break;
        case interfaces.Region.ASIA:
            codeParse = constants.JP_GAME_CODE_REGEX.exec(game.InitialCode);
            break;
        case interfaces.Region.AMERICAS:
            return util_1.deprecate(() => {
                var _a;
                return (((_a = constants.US_GAME_CODE_REGEX.exec(game.game_code)) === null || _a === void 0 ? void 0 : _a.length) || false
                    ? constants.US_GAME_CODE_REGEX.exec(game.game_code)[1]
                    : '');
            }, 'game_code is no longer returned by the API for American games so it can no longer be parsed from the data.', 'DEP0001')();
    }
    return (codeParse && codeParse.length > 1) ? codeParse[1] : null;
};
/**
 * Extracts NSUID information from the game object.
 *
 * @param game The game object returned from one of the other methods.
 * @param region Region code
 * @returns The 14-digits NSUID
 */
exports.parseNSUID = (game, region) => {
    switch (region) {
        case interfaces.Region.EUROPE:
            return game.nsuid_txt ? game.nsuid_txt[0] : null;
        case interfaces.Region.ASIA:
            const nsuidParse = constants.JP_NSUID_REGEX.exec(game.LinkURL);
            return (nsuidParse && nsuidParse.length > 0) ? nsuidParse[0] : null;
        default:
        case interfaces.Region.AMERICAS:
            return game.nsuid;
    }
};
//# sourceMappingURL=nintendo-switch-eshop.js.map