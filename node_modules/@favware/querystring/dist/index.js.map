{"version":3,"file":"index.js","sources":["../src/types.ts","../src/querystring.ts"],"sourcesContent":["/**\n * Options for the Stringify function\n * @typedef {StringifyOptions} StringifyOptions tringify Options\n * @property {string} [separator] separator the querystring should get\n * @property {string} [equals] equals sign the querystring should use\n * @property {boolean} [includeQuestion] whether the querystring should be prefixed with a `?`\n */\nexport type StringifyOptions = {\n  separator?: string;\n  equals?: string;\n  includeQuestion?: boolean;\n};\n\n/**\n * Options for the Parse function\n * @typedef {ParseOptions} ParseOptions Parse Options\n * @property {string} [separator] separator the querystring has\n * @property {string} [equals] equals sign the querystring has\n */\nexport type ParseOptions = {\n  separator?: string;\n  equals?: string;\n};\n\n/**\n * Generic object for type definitions\n * @typedef {QuerystringObject} QuerystringObject Generic object\n * @property {any} key String based key with value of any type\n * @private\n */\nexport type QuerystringObject = {\n  [key: string]: string | number | boolean | any;\n};\n\n/**\n * Extension to generic object defining an absolute error property\n * @typedef {QuerystringError} QuerystringError Generic Error Object\n * @property {string} err Error with a string value\n * @private\n */\nexport type QuerystringError = {\n  err: string;\n} & QuerystringObject;\n\n/**\n * Predefined potential sources for errors\n * @typedef {FunctionSource} FunctionSource Source Reference Enum\n * @property {FunctionSource.Parse} Parse for when the source is {@link parse}\n * @property {FunctionSource.Stringify} Stringify for when the source is {@link stringify}\n * @private\n */\nexport enum FunctionSource {\n  Parse = 'parse',\n  Stringify = 'stringify',\n}","import { FunctionSource, ParseOptions, QuerystringError, QuerystringObject, StringifyOptions } from './types';\n\n/**\n * Checks what kind of primitive type the property is and transforms accordingly\n * Used for stringify\n * @param v Input to check for primitive type\n * @private\n */\nconst stringifyPrimitive = (v: any): string => {\n  switch (typeof v) {\n    case 'string':\n      return v;\n    case 'boolean':\n      return v ? 'true' : 'false';\n    case 'number':\n      return isFinite(v) ? v.toString() : '';\n    default:\n      return '';\n  }\n};\n\n/**\n * Gracefully handles errors thrown by other functions\n * @param {string} err The error message to parse\n * @param {FunctionSource} source The source of the error, one of {@link FunctionSource}\n * @private\n */\nconst handleQuerystringError = (err: string, source: FunctionSource): string | QuerystringError => {\n  switch (source) {\n    case FunctionSource.Parse:\n      return { err };\n    case FunctionSource.Stringify:\n    default:\n      return err;\n  }\n};\n\n/**\n * Stringifies an object\n * @method\n * @name stringify\n * @param {QuerystringObject} obj Object to stringify\n * @param {StringifyOptions} [options] Options for the stringify, see {@link IStringifyOptions}\n * @returns {string}\n */\nexport const stringify = (obj: QuerystringObject, options: StringifyOptions = { separator: '&', equals: '=', includeQuestion: false }): string => {\n  try {\n    if (!obj || Object.keys(obj).length <= 0) throw new Error('object_is_empty');\n    if (typeof obj !== 'object') throw new Error('input_not_object');\n    if (!options.separator) options.separator = '&';\n    if (!options.equals) options.equals = '=';\n    if (!options.includeQuestion) options.includeQuestion = false;\n    const keys = Object.keys(obj).sort()\n      .map(key => {\n        const ks = encodeURIComponent(stringifyPrimitive(key)) + options.equals;\n        if (obj[key] === undefined) return '';\n        if (obj[key] === null) return encodeURIComponent(key);\n        if (Array.isArray(obj[key])) {\n          return obj[key]\n            .map((v: string) => ks + encodeURIComponent(stringifyPrimitive(v)))\n            .join(options.separator);\n        }\n        return (\n          ks + encodeURIComponent(stringifyPrimitive(obj[key]))\n        );\n      }).filter(Boolean);\n\n    if (options.includeQuestion) keys[0] = `?${keys[0]}`;\n    return keys.join(options.separator);\n  } catch (err) {\n    if (/object_is_empty/i.test(err.toString())) {\n      return `${options.includeQuestion ? '?' : ''}${encodeURIComponent(stringifyPrimitive(obj))}`;\n    }\n    if (/input_not_object/i.test(err.toString())) {\n      return handleQuerystringError(\n        '@Favware/Querystring: Your input was not an object. Please supply an object when using Stringify',\n        FunctionSource.Stringify\n      ) as string;\n    }\n\n    return err;\n  }\n};\n\n/**\n * Parses a querystring back to an object\n * @method\n * @name parse\n * @param {string} qs Querystring to parse\n * @param {ParseOptions} [options] Options for the parse, see {@link IParseOptions}\n * @returns {QuerystringObject}\n */\nexport const parse = (qs: string = '', options: ParseOptions = { separator: '&', equals: '=' }): QuerystringObject => {\n  try {\n    if (typeof qs !== 'string') throw new Error('input_not_string');\n    if (qs === '') return {};\n    if (/^https?:\\/\\//.test(qs)) qs = qs.split('?')[1];\n    if (!options.separator) options.separator = '&';\n    if (!options.equals) options.equals = '=';\n    if (qs.startsWith('?')) qs = qs.slice(1);\n    const obj: QuerystringObject = {};\n    const regexp = /\\+/g;\n    const queries: string[] = qs.split(options.separator);\n    const maxKeys = 1000;\n\n    let len = queries.length;\n    if (maxKeys > 0 && len > maxKeys) len = maxKeys;\n\n    for (const query of queries) {\n      const x = query.replace(regexp, '%20');\n      const idx = x.indexOf(options.equals);\n      let kstr;\n      let vstr;\n\n      if (idx >= 0) {\n        kstr = x.substr(0, idx);\n        vstr = x.substr(idx + 1);\n      } else {\n        kstr = x;\n        vstr = '';\n      }\n\n      const k = decodeURIComponent(kstr);\n      const v = decodeURIComponent(vstr);\n\n      if (!obj.hasOwnProperty(k)) {\n        obj[k] = v;\n      } else if (Array.isArray(obj[k])) {\n        obj[k].push(v);\n      } else {\n        obj[k] = [obj[k], v];\n      }\n    }\n\n    return obj;\n\n  } catch (err) {\n    if (/input_not_string/i.test(err.toString())) {\n      return handleQuerystringError(\n        '@Favware/Querystring: Your input was not an string. Please supply a string when using Parse',\n        FunctionSource.Parse\n      ) as QuerystringError;\n    }\n    return err;\n  }\n};\n\nexport default stringify;"],"names":["FunctionSource","stringifyPrimitive","v","isFinite","toString","handleQuerystringError","err","source","Parse","Stringify","stringify","obj","options","separator","equals","includeQuestion","Object","keys","length","Error","sort","map","key","ks","encodeURIComponent","undefined","Array","isArray","join","filter","Boolean","test","parse","qs","split","startsWith","slice","regexp","queries","len","queries_1","_i","x","replace","idx","indexOf","kstr","vstr","substr","k","decodeURIComponent","hasOwnProperty","push"],"mappings":"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"}