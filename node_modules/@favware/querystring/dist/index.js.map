{"version":3,"file":"index.js","sources":["../src/types.ts","../src/querystring.ts"],"sourcesContent":["/** Options for the {@link stringify} function */\nexport interface StringifyOptions {\n  /** Separator the querystring should get */\n  separator?: string;\n  /** Equals sign the querystring should use */\n  equals?: string;\n  /** Whether the querystring should be automatically prefixed with a `?` */\n  includeQuestion?: boolean;\n}\n\n/** Options for the {@link parse} function */\nexport interface ParseOptions {\n  /** Separator the querystring has */\n  separator?: string;\n  /** Equals sign the querystring has */\n  equals?: string;\n}\n\n/** Generic object for type definitions */\nexport interface QuerystringObject {\n  /** String based key with value of any type */\n  [key: string]: string | number | boolean | any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/** Extension to generic object defining an absolute error property */\nexport type QuerystringError = {\n  /** Error with a string value */\n  err: string;\n} & QuerystringObject;\n\n/** Predefined potential sources for errors */\nexport enum FunctionSource {\n  /** For when the source is {@link parse} */\n  Parse = 'parse',\n  /** For when the source is {@link stringify} */\n  Stringify = 'stringify'\n}\n","import { FunctionSource, ParseOptions, QuerystringError, QuerystringObject, StringifyOptions } from './types';\n\n/**\n * Checks what kind of primitive type the property is and transforms accordingly\n *\n * @remarks\n * Used for stringify\n *\n * @param v Input to check for primitive type\n */\nconst stringifyPrimitive = <T extends unknown>(v: T): string => {\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  switch (typeof v) {\n    case 'string':\n      return v;\n    case 'boolean':\n      return v ? 'true' : 'false';\n    case 'number':\n      return isFinite(v) ? v.toString() : '';\n    default:\n      return '';\n  }\n};\n\n/**\n * Gracefully handles errors thrown by other functions\n *\n * @param err The error message to parse\n * @param source The source of the error, one of {@link FunctionSource}\n */\nconst handleQuerystringError = (err: string, source: FunctionSource): string | QuerystringError => {\n  switch (source) {\n    case FunctionSource.Parse:\n      return { err };\n    case FunctionSource.Stringify:\n    default:\n      return err;\n  }\n};\n\n/**\n * Stringifies an object\n *\n * @param obj Object to stringify\n * @param options Options for the stringify, see {@link IStringifyOptions}\n * @returns The stringified query object\n * @example\n * ```ts\n * stringify({prop: 'value', prop2: 'value2'})\n * ```\n *\n * @example\n * ```ts\n * stringify({prop: 'value', prop2: 'value2'}, {separator: '&', equals: '=', includeQuestion: false})\n * ```\n *\n * @example\n * ```ts\n * stringify({prop: 'value', prop2: 'value2'}, {separator: '&&', equals: '=', includeQuestion: true})\n * ```\n */\nexport const stringify = (\n  obj: QuerystringObject,\n  options: StringifyOptions = { separator: '&', equals: '=', includeQuestion: false }\n): string => {\n  try {\n    if (!obj || Object.keys(obj).length <= 0) throw new Error('object_is_empty');\n    if (typeof obj !== 'object') throw new Error('input_not_object');\n    if (!options.separator) options.separator = '&';\n    if (!options.equals) options.equals = '=';\n    if (!options.includeQuestion) options.includeQuestion = false;\n    const keys = Object.keys(obj)\n      .sort() // eslint-disable-line @typescript-eslint/require-array-sort-compare\n      .map(key => {\n        const ks = encodeURIComponent(stringifyPrimitive(key)) + options.equals!;\n        if (obj[key] === undefined || obj[key] === null) return '';\n        if (Array.isArray(obj[key])) {\n          return obj[key].map((v: string) => ks + encodeURIComponent(stringifyPrimitive(v))).join(options.separator);\n        }\n\n        return ks + encodeURIComponent(stringifyPrimitive(obj[key]));\n      })\n      .filter(Boolean);\n\n    if (options.includeQuestion) keys[0] = `?${keys[0]}`;\n\n    return keys.join(options.separator);\n  } catch (err) {\n    if (/object_is_empty/i.test(err.toString())) {\n      return `${options.includeQuestion ? '?' : ''}${encodeURIComponent(stringifyPrimitive(obj))}`;\n    }\n    if (/input_not_object/i.test(err.toString())) {\n      return handleQuerystringError(\n        '@Favware/Querystring: Your input was not an object. Please supply an object when using Stringify',\n        FunctionSource.Stringify\n      ) as string;\n    }\n\n    return err;\n  }\n};\n\n/**\n * Parses a querystring back to an object\n *\n * @param qs Querystring to parse\n * @param options Options for the parse, see {@link IParseOptions}\n * @returns A JavaScript object of the parsed parameters\n * @example\n * ```ts\n * parse('?prop=value&prop2=value2')\n * ```\n *\n * @example\n * ```ts\n * parse('?prop=value&prop2=value2', {separator: '&', equals: '='})\n * ```\n *\n * @example\n * ```ts\n * parse('prop=value&&prop2=value2', {separator: '&&', equals: '='})\n * ```\n */\nexport const parse = (qs = '', options: ParseOptions = { separator: '&', equals: '=' }): QuerystringObject => {\n  try {\n    if (typeof qs !== 'string') throw new Error('input_not_string');\n    if (qs === '') return {};\n    if (/^https?:\\/\\//.test(qs)) qs = qs.split('?')[1];\n    if (!options.separator) options.separator = '&';\n    if (!options.equals) options.equals = '=';\n    if (qs.startsWith('?')) qs = qs.slice(1);\n    const obj: QuerystringObject = {};\n    const regexp = /\\+/g;\n    const queries: string[] = qs.split(options.separator);\n    const maxKeys = 1000;\n\n    let len = queries.length;\n    if (maxKeys > 0 && len > maxKeys) len = maxKeys;\n\n    for (const query of queries) {\n      const x = query.replace(regexp, '%20');\n      const idx = x.indexOf(options.equals);\n      let kstr;\n      let vstr;\n\n      if (idx >= 0) {\n        kstr = x.substr(0, idx);\n        vstr = x.substr(idx + 1);\n      } else {\n        kstr = x;\n        vstr = '';\n      }\n\n      const k = decodeURIComponent(kstr);\n      const v = decodeURIComponent(vstr);\n\n      if (!(k in obj)) {\n        obj[k] = v;\n      } else if (Array.isArray(obj[k])) {\n        obj[k].push(v);\n      } else {\n        obj[k] = [obj[k], v];\n      }\n    }\n\n    return obj;\n  } catch (err) {\n    if (/input_not_string/i.test(err.toString())) {\n      return handleQuerystringError(\n        '@Favware/Querystring: Your input was not an string. Please supply a string when using Parse',\n        FunctionSource.Parse\n      ) as QuerystringError;\n    }\n\n    return err;\n  }\n};\n\nexport default stringify;\n"],"names":["FunctionSource","stringifyPrimitive","v","isFinite","toString","handleQuerystringError","err","source","Parse","Stringify","stringify","obj","options","separator","equals","includeQuestion","Object","keys","length","Error","sort","map","key","ks","encodeURIComponent","Array","isArray","join","filter","Boolean","test","qs","split","startsWith","slice","regexp","queries","len","queries_1","_i","x","replace","idx","indexOf","kstr","vstr","substr","k","decodeURIComponent","push"],"mappings":"aA+BA,IAAYA,0DAAAA,EAAAA,yBAAAA,0CAIVA,wBCzBF,IAAMC,EAAqB,SAAoBC,GAE7C,cAAeA,GACb,IAAK,SACH,OAAOA,EACT,IAAK,UACH,OAAOA,EAAI,OAAS,QACtB,IAAK,SACH,OAAOC,SAASD,GAAKA,EAAEE,WAAa,GACtC,QACE,MAAO,KAUPC,EAAyB,SAACC,EAAaC,GAC3C,OAAQA,GACN,KAAKP,uBAAeQ,MAClB,MAAO,CAAEF,OACX,KAAKN,uBAAeS,UACpB,QACE,OAAOH,IAyBAI,EAAY,SACvBC,EACAC,gBAAAA,GAA8BC,UAAW,IAAKC,OAAQ,IAAKC,qBAE3D,IACE,IAAKJ,GAAOK,OAAOC,KAAKN,GAAKO,QAAU,EAAG,MAAM,IAAIC,MAAM,mBAC1D,GAAmB,iBAARR,EAAkB,MAAM,IAAIQ,MAAM,oBACxCP,EAAQC,YAAWD,EAAQC,UAAY,KACvCD,EAAQE,SAAQF,EAAQE,OAAS,KACjCF,EAAQG,kBAAiBH,EAAQG,oBACtC,IAAME,EAAOD,OAAOC,KAAKN,GACtBS,OACAC,cAAIC,GACH,IAAMC,EAAKC,mBAAmBvB,EAAmBqB,IAAQV,EAAQE,OACjE,gBAAIH,EAAIW,IAAmC,OAAbX,EAAIW,GAAsB,GACpDG,MAAMC,QAAQf,EAAIW,IACbX,EAAIW,GAAKD,cAAKnB,GAAc,OAAAqB,EAAKC,mBAAmBvB,EAAmBC,OAAKyB,KAAKf,EAAQC,WAG3FU,EAAKC,mBAAmBvB,EAAmBU,EAAIW,QAEvDM,OAAOC,SAIV,OAFIjB,EAAQG,kBAAiBE,EAAK,GAAK,IAAIA,EAAK,IAEzCA,EAAKU,KAAKf,EAAQC,WACzB,MAAOP,GACP,MAAI,mBAAmBwB,KAAKxB,EAAIF,aACpBQ,EAAQG,gBAAkB,IAAM,IAAKS,mBAAmBvB,EAAmBU,IAEnF,oBAAoBmB,KAAKxB,EAAIF,YACxBC,EACL,mGACAL,uBAAeS,WAIZH,oCAyBU,SAACyB,EAASnB,gBAATmB,mBAASnB,GAA0BC,UAAW,IAAKC,OAAQ,MAC/E,IACE,GAAkB,iBAAPiB,EAAiB,MAAM,IAAIZ,MAAM,oBAC5C,GAAW,KAAPY,EAAW,MAAO,GAClB,eAAeD,KAAKC,KAAKA,EAAKA,EAAGC,MAAM,KAAK,IAC3CpB,EAAQC,YAAWD,EAAQC,UAAY,KACvCD,EAAQE,SAAQF,EAAQE,OAAS,KAClCiB,EAAGE,WAAW,OAAMF,EAAKA,EAAGG,MAAM,IACtC,IAAMvB,EAAyB,GACzBwB,EAAS,MACTC,EAAoBL,EAAGC,MAAMpB,EAAQC,WAGvCwB,EAAMD,EAAQlB,OACCmB,EAHH,MAGkBA,EAHlB,KAKhB,IAAoB,QAAAC,IAAAC,WAAAA,IAAS,CAAxB,IACGC,OAAUC,QAAQN,EAAQ,OAC1BO,EAAMF,EAAEG,QAAQ/B,EAAQE,QAC1B8B,SACAC,SAEAH,GAAO,GACTE,EAAOJ,EAAEM,OAAO,EAAGJ,GACnBG,EAAOL,EAAEM,OAAOJ,EAAM,KAEtBE,EAAOJ,EACPK,EAAO,IAGT,IAAME,EAAIC,mBAAmBJ,GACvB1C,EAAI8C,mBAAmBH,GAEvBE,KAAKpC,EAEAc,MAAMC,QAAQf,EAAIoC,IAC3BpC,EAAIoC,GAAGE,KAAK/C,GAEZS,EAAIoC,GAAK,CAACpC,EAAIoC,GAAI7C,GAJlBS,EAAIoC,GAAK7C,EAQb,OAAOS,EACP,MAAOL,GACP,MAAI,oBAAoBwB,KAAKxB,EAAIF,YACxBC,EACL,8FACAL,uBAAeQ,OAIZF"}